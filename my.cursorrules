Express.js rules

Use proper middleware order: correlation ID → security (helmet, cors, hpp) → logger → body parsers → auth → validation → routes → 404 → error handler

Organize routes using Express Router with versioned prefixes (e.g., /v1); keep controllers thin and delegate to services

Use async/await with centralized async error forwarding; never leave unhandled promise rejections

Create a centralized error handler middleware as the last middleware; map domain/app errors to proper HTTP codes and never leak internals in production

Use environment variables validated at startup by a schema module (e.g., zod/class-validator); never read process.env outside the config module

Implement request validation at the edge (params, query, body, headers); derive TypeScript types from schemas to avoid drift

Use middleware for authentication (JWT/JWKs, aud/iss checks) and authorization (RBAC/ABAC via roles/scopes)

Use appropriate HTTP status codes in responses and a consistent error response shape { code, message, details?, requestId }

Prefer strict TypeScript settings: strict, noImplicitAny, noUncheckedIndexedAccess, exactOptionalPropertyTypes, useUnknownInCatchVariables

Avoid any; prefer unknown with explicit narrowing; use import type for type-only imports

Define DTOs and domain types explicitly; never pass raw req.body/req.query into services

Keep domain logic framework-agnostic; Express concerns live only in controllers/middlewares

Standardize response formats; set Content-Type explicitly; use ISO-8601 UTC timestamps and integers for monetary minor units

Implement idempotency on unsafe endpoints (e.g., POST) via Idempotency-Key and request hashing/store

Use cursor-based pagination for large collections; validate and bound limit

Add correlation/request ID propagation; echo X-Request-Id and include it in logs and error payloads

Enable structured logging (JSON) with request/response metadata, latency, userId, status code; log at INFO for normal ops, WARN/ERROR for failures

Expose health endpoints: /healthz (liveness) and /readyz (readiness with downstream checks); return minimal payloads

Apply rate limiting and request slowdown (per IP and per user); protect auth and write endpoints aggressively

Configure CORS with explicit allowlists and credentials rules; never use * with cookies or Authorization

Set body size limits and file upload constraints; prefer pre-signed URLs for large file transfers

Apply security headers (helmet) and HTTP parameter pollution protection (hpp); disable x-powered-by

Set server timeouts (headers, idle, request) and client timeouts for outbound calls; reject slowloris patterns

Add resilience patterns for outbound calls: retries with jitter, timeouts, circuit breakers, bulkheads

Use the outbox pattern for reliable message publishing within DB transactions; configure dead-letter queues for poison messages

Make consumers idempotent; de-duplicate using message keys and persistence; set sensible max concurrency and backoff

Version public APIs; maintain deprecation windows; keep OpenAPI/AsyncAPI specs as the source of truth and generate typed clients

Enforce database migrations in CI/CD; use typed query layers/ORMs (e.g., Prisma/Drizzle) and narrow repository interfaces

Encapsulate transactions at service boundaries; avoid leaking ORM entities to controllers

Use caching deliberately (memory for hot config, Redis for shared); define key namespaces and TTLs; document invalidation strategies

Emit metrics (Prometheus) for latency, throughput, error rates, queue lag, and dependency health; set SLOs and alerts

Enable distributed tracing (OpenTelemetry) across HTTP/DB/MQ; propagate traceparent/baggage between services

Prefer immutable containers; run compiled JS (no ts-node in prod); one process per container; non-root user; minimal base images

Implement graceful shutdown on SIGTERM/SIGINT: stop accepting, drain inflight requests, close pools/channels, flush logs

Validate and sanitize all untrusted input; escape output; treat file names, paths, and headers as tainted

For cookie-based sessions, enable SameSite/HttpOnly/Secure; for token APIs, avoid CSRF and rely on Authorization headers

Use ETags/Cache-Control on cacheable GETs; avoid caching authenticated responses unless explicitly safe

Keep dependencies minimal and audited; pin Node and package versions; monitor for vulnerabilities and update regularly

Enforce linting/formatting (eslint + Prettier), type checks (tsc --noEmit), tests (unit/integration/e2e), and contract tests in CI

Document operational runbooks (rate limit tuning, circuit breaker thresholds, retry policies, rollback steps) alongside the service

Prefer configuration over conditionals: feature flags and environment-specific config, not if (env === 'prod') branches in logic

Log PII sparingly; redact secrets/tokens; comply with data retention policies; encrypt at rest and in transit

Use trust proxy only behind known proxies/load balancers; never depend on untrusted X-Forwarded-* without validation

Provide consistent 404 handlers for unknown routes and 405 for unsupported methods on known routes

Keep routers small and cohesive; split by bounded contexts/modules; avoid circular dependencies between modules

Validate headers important for contracts (e.g., Accept, Content-Type, Authorization, Idempotency-Key); respond with 415/406 as needed

Prefer asynchronous background processing for long-running tasks; immediately acknowledge and process via queues or schedulers

Record and surface build metadata (service name, version, git sha) in logs and /version endpoint for traceability

code should obey the rules defined in the .eslintrc.json, .prettierrc, .htmlhintrc, and .editorconfig files

functions and methods should not have more than 4 parameters

functions should not have more than 50 executable lines

lines should not be more than 80 characters

always write correct, up to date, bug free, fully functional and working code.

focus on performance, readability, and maintainability.

before providing an answer, double check your work